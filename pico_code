from machine import Pin, ADC
import time
import network
import ubinascii
import mqtt
import urequests as requests
from stepper import Stepper
from servo import Servo

# initialize servos 
base_servo = Servo(12, 500, 2500, 0.0, 180, 50)
elbow_servo = Servo(13, 500, 2500, 0.0, 180.0, 50)

# initialize suction pins
suction = Pin(16, Pin.OUT)

# initialize stepper
step_pin = 17
dir_pin = 18

ms1 = Pin(19, Pin.OUT, Pin.PULL_DOWN) # different combos of ms1,ms2 states gives microstep sizes. Low Low is 1 step
ms2 = Pin(20, Pin.OUT, Pin.PULL_DOWN)
enable = Pin(21, Pin.OUT, Pin.PULL_DOWN) # when enable is on, stepper is disengaged. Use to keep stepper from overheating from staying on

enable.on() 
ms1.off()
ms2.off()

slider = Stepper(step_pin,dir_pin,steps_per_rev=200,speed_sps=200) # in our system, 200 steps = 4 cm irl motion

slider.overwrite_pos(0) # sets whatever position is curent as 0

wifi = {"ssid":"Tufts_Wireless","pass":""}
def connect_wifi(wifi):
    station = network.WLAN(network.STA_IF)
    station.active(True)
    mac = ubinascii.hexlify(network.WLAN().config('mac'),':').decode()
    print("MAC " + mac)

    station.connect(wifi['ssid'],wifi['pass'])
    while not station.isconnected():
        time.sleep(1)
    print('Connection successful')
    print(station.ifconfig())
 
def move_stepper(message):
    message = int(message)
    enable.off()
    slider.target(message) # move sent number of steps
    slider.stop()
    enable.on()

def move_servo(angles):
    angle1, angle2 = angles
    angle1 = int(angle1)
    angle2 = int(angle2)
    
    if 135.0 >= angle1 >= 50.0:
        base_servo.write(angle1)
    elif angle > 135.0:
        base_servo.write(135)
    elif angle < 50.0:
        base_servo.write(50.0)
    else:
        pass

    if 135.0 >= angle2 >= 50.0:
        elbow_servo.write(angle2)
    elif angle > 135.0:
        elbow_servo.write(135)
    elif angle < 50.0:
        elbow_servo.write(50.0)
    else:
        pass

def control_suction(message):
    if message == "on":
        suction.value(1)
    elif message == "off":
        suction.value(0)
    else:
        print("the vacuum is confused :(")
 
def whenCalled(topic, msg):
    top = topic.decode()
    msg = msg.decode()
    if top == "stepper":
        move_stepper(msg)
    elif top == "servo":
        move_servo(msg)
    elif top == "suction":
        control_suction(msg)
    else:
        print("i can't read this message :(")

def main():
    try:
        connect_wifi(wifi)
        fred = mqtt.MQTTClient('SarahElijah', 'broker.hivemq.com', keepalive=100)
        print('Connected')
        fred.connect()
        fred.set_callback(whenCalled)
    except OSError as e:
        print('Failed')
        return
    fred.subscribe('servo')
    fred.subscribe('stepper')
    fred.subscribe('suction')
    try:
        while True:
            fred.check_msg() 
            time.sleep(.1)
    except Exception as e:
        print(e)
    finally:
        fred.disconnect()
        print('done')


main()


